
:toc:

= `traccar-api-client` implementation

This software is based on a generated *Java Spring REST Client* from the traccar specification.
The single package (`bm.traccar.api`) implementation wraps the Java client in a *Spring* @Service
to be applied wherever feasible. The API client completely hides the REST intricities
inside regular Java methods.

The `traccar-api-client` is basically a single package application or rather _service_. 
In addition there is a websocket package to receive live information from the Tracking System.


== openapi-generator

As Traccar provides a REST specification in form of a `yaml` file we faciliate the 
link:https://github.com/OpenAPITools/openapi-generator[OpenAPI Generator]

[quote, see github.com/OpenAPITools/openapi-generator]
____
OpenAPI Generator allows generation of API client libraries (SDK generation), 
server stubs, documentation and configuration automatically 
given an OpenAPI Spec v3.
____

Note that this Java code generation takes place in the isolated 
link:../../traccar-openapitools-client/readme.adoc[`traccar-openapitools-client`] 
project. It has to run before this project which is build around the generated artifact.

[TIP]
====
To get more details on the generation you can read the project notes:
link:../../traccar-openapitools-client/readme.adoc[openapitools-client]
====

You can check 
link:https://ademico-software.com/how-to-generate-the-client-api-for-an-openapi-rest-service/[Generate the client using Maven] 
for a starting point on how to apply Maven properties etc.


== Traccar REST

Traccar `v6.7` provides *17 APIs* (see `package bm.traccar.generated.api`)
for all aspects of GPS Tracking. 
The `traccar-api-client` defines _one single (nested) API interface:_ 
`bm.traccar.api.Api`, which allows us to switch the implementation.
This was required, for example, when changing from swagger to OpenAPI (3 to 3.1). +

[TIP]
====
Therefor you should stick to the `bm.traccar.api.Api interface` 
to connect your program logic!
====

=== Data Transfer Objects - DTOs ...

In addition the `traccar-api-client` provides *21 Data Transfer Objects* +
see `package bm.traccar.generated.model.dto`

These DTO _represent_ the different System Entities 
and are used to exchange information with the server. +
For example the User API call to 
link:https://www.traccar.org/api-reference/#tag/Users/paths/~1users/post[Create a User] 
is provided as Java method by the Api interface:

[source,java]
----
    public interface Api {
           interface Users {
                User createUser(User user) throws ApiException;
----

In your code you can easily create a `new User()` in your software 

[source,java]
----
    User userIN = new User();
    userIN.setName(usr);
    userIN.setEmail(mail);
    userIN.setPassword(pwd);
    userIN. ...
----
    
and  then create it on server side and receive a copy:

[source,java]
----
    User userOUT =  api.users.createUser(userIN);
----

Note that `userIN` and `userOUT` are different instances.
The latter provides the `userId` provided by the Traccar Model
and is vital to use in the client server communication.
The ID is usually hidden for external users (i.e. in the UI),
but required for unambiguously user identification!

=== ... are not System Entities

Nevertheless you should always distinguish _Data Transfer Objects_
from actual Entities in the Systems _Entity Relations Model_ - ERM.
_The Traccar System_ is build around the _Traccar Data Model_,
which is represented in the 
link:https://github.com/traccar/traccar/tree/master/src/main/java/org/traccar/model[model package],
while the DTOs are created in the
link:https://github.com/traccar/traccar/tree/master/src/main/java/org/traccar/api/resource[resource package].
The Entities are only accessed by Traccar itself, while DTOs are snapshots of them.
Of course you can always peek into the Traccar Database to check what's going on.

This is similar to DNA and RNA: +
The DNA (ERM) is part of the _living_ organic System, +
while the RNA (DTOs) is simply a copy of the DNA from a certain point in time.


== Traccar sub Api implementations

This project is part of a larger software and therefor the Traccar Api Endpoints (`operationId`)
are implemented in the order required by the main application.

=== SessionApi

We can find all generated sub APIs in the `bm.traccar.generated.api` package. 
For example we use the `UsersApi` and `DevicesApi` by setting the authentication,
sending a request and receive entities.
The `ApiClient` class holds the username and password. 
When you call an API method, it will automatically construct and add the Authorization header. 
This works perfectly for APIs that are stateless and check the basic auth header on every request.

The `SessionApi` is a special case as `REST` and `HTTP` are defined as a stateless protocols.
A session makes sense, if we log into the browser and keep it open.
For the `traccar-api-client` we don't need to establish a session for REST interactions.
The sole purpose is to use the `SessionApi` to create a session 
and retrieve a `JSESSIONID` (Java Session Id) to be used with a websocket connection.

You can make a `POST` request to the `/api/session` endpoint with the user's email and password. 
This will create a session and return a Session Cookie managed by Jetty. 
This process is implemented in the `ApiService` and can be called with

[source,java]
----
    String jSessionId = api.session.createSessionGetJsessionId(userMail, userPassword);
----

That's all we need from the `SessionApi` and we will move on to the websocket implementation
with the returned `JSESSIONID` for the provided User.
When you connect to websocket endpoint `/api/socket` (Not the REST endpoint `/api/session`!), 
the server checks for the presence of a valid session cookie 
to authorize _the real-time data stream_.



== Traccar `ApiAspect` and `ApiException`

This API client implementation applies Aspect-Oriented Programming (AOP) 
as the technique for handling exceptions in Spring Boot applications. 
This way all exception handling happens in one central `ApiAspect` class 
and avoids code duplication.

Generally any problem in the client software should through an `ApiException` 
to take over responsibility and to provide useful messages for developers 
and wrap the cause for deeper analysis.

As you can see in the `bm.traccar.api.ApiAspect` class 
the `@Pointcut` includes all `*Api` classes and methods in :

      @Pointcut("execution(public * bm.traccar.generated.api.*Api.*(..))")

and the `Joinpoint` is defined to only catch `RestClientExceptions`,
wrap them in an `ApiException` and throw it for the method execution:

  public void afterThrowingApiMethod(JoinPoint joinPoint, RestClientException rcEx)
      throws ApiException {

Note that the `ApiException` is a `RuntimeException` and 
the caller is not forced by the compiler to catch it.
However you should handle it as good practice
and to ensure that you have a binding communication.

[source,java]
-----------------
Spring AOP
invocation order
    invoke **UsersApi.usersPost(..) ** <-------------+
      invoke ApiClient.selectHeaderAccept(..)        |
      invoke ApiClient.selectHeaderContentType(..)   |
      invoke ApiClient.invokeAPI(..)                 |
    Exception in ApiMethod: **UsersApi.usersPost(..) **
-----------------
