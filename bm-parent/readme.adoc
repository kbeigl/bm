
:toc:

= Multi Module repository

This `bm-sim` repository is a 
link:https://maven.apache.org/guides/mini/guide-multiple-modules.html[Maven Multiple Module] 
project.
The Maven Reactor mechanism makes sure to collect all modules 
and assert correct build order with every `mvn` command executed. 
It assures that any project is build as required by another.

== project nature

The Java development cycle is defined by the major components:

=== Maven build tool 
 
Implies major versioning, dependency management, 
plugin configuration, and build lifecycle.
If available and feasible external tools, like the 
link:../bm-traccar/traccar-openapitools-client/readme.adoc[OpenAPI Generator]
are integrated into the lifecycle to generate code for subsequent modules.


=== Camel integration framework 

Apache Camel has a very powerful bean injection framework 
to allow developers _to focus on solving business problems_. 

At its core, Apache Camel is an integration engine, which can be used 
to facilitate interactions between a wide and varied array of technologies.
These bridges between service- and technology Endpoints, 
the Routes are implemented on an engine - the CamelContext, 
and they communicate with “exchange messages”.

For this repository Camel is used to glue independant Units together.


=== Spring Framework and Spring Boot Application  
 
Spring context, dependency injection, and application startup.

https://camel.apache.org/camel-spring-boot/4.10.x/spring-boot.html

Spring Boot component provides auto-configuration for Apache Camel. 
Our opinionated auto-configuration of the Camel context 
auto-detects Camel routes available in the Spring context 
and registers the key Camel utilities 
(like producer template, consumer template and the type converter) as beans.

[NOTE]
====
 Spring Boot will auto-configure Camel for you.
====


=== Testing 
 
For details see:  
link:../bm-traccar/dox/testSetup.adoc[Testing] 

For initial setup of testing and 
developer switch from JUnit to Integration Testing see: 
link:../bm-traccar/dox/developmentSetup.adoc[Development and Production Setup]


== root project `bm-sim` 

The Maven Bill of Materials (BOM) is collected the root `pom.xml` file, i.e. _aggregator POM_ 
that defines common dependencies, versions, properties and other dependent Maven Projects.
It is considered good development practice to run `mvn clean install` 
in the repository root directory in order to create all artifacts 
in the local `.m2/repository`. After that the developer can exclusively
focus on the project s/he is assigned to. 

see link:https://docs.microfocus.com/doc/205/saas/bestpracticesmavenprojects[structuring Maven projects and modules]

For team development you should work with the `-SNAPSHOT` tag and a central (Nexus) Server 
over your personal `.m2` repo.
This way all team members are accessing the same (changeing) artifact 
and the complete build process can be reduced to the module and artifact in focus.


=== `<modules>`

This approach reduces duplication and allows to share configurations between modules.
Practically the parent pom can be seen as the cover sheet with project information
and most important - the list of submodules.

see [jeets repository] ...

[source,xml]
----
    <modules>
        <module>bm-parent</module>
        <module>bm-traccar</module>
                ...
    </modules
----

== `bm-parent` project

The parent project is the first module called in the build process. +
It starts by running the `os-maven-plugin` 

[source,text]
-----------------
[INFO] Scanning for projects...
[INFO] ---------------------------------------------------
[INFO] Detecting the operating system and CPU architecture
[INFO] ---------------------------------------------------
[INFO] os.detected.name: linux
[INFO] os.detected.arch: x86_64
[INFO] os.detected.bitness: 64
[INFO] os.detected.version: 6.11
[INFO] os.detected.version.major: 6
[INFO] os.detected.version.minor: 11
[INFO] os.detected.release: tuxedo
[INFO] os.detected.release.version: 22.04
[INFO] os.detected.release.like.tuxedo: true
[INFO] os.detected.release.like.ubuntu: true
[INFO] os.detected.release.like.debian: true
[INFO] os.detected.classifier: linux-x86_64
-----------------

which provides Maven parameters, like `${os.detected.name}`, +
to direct the build lifecycle as required for your targeted system.

=== project setup

==== `<properties>`

The properties of the parent project are applied to the full repo.
Here the main parameters for Java, JDK, Maven with components and plugins,
the driving Camel version in conjunction with spring boot.


==== `<dependencyMgm>` and top level BOM

The repository versioning of Java archives is defined by 

    <dependencyManagement>
        <dependencies>
            <dependency>
                <groupId>org.apache.camel.springboot</groupId>
                <artifactId>camel-spring-boot-bom</artifactId>
            </dependency>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
            </dependency>
        </dependencies>
    </dependencyManagement>

It is recommended to import Camel Spring Boot BOM before Spring Boot BOM
to ensure Camel dependencies are using supported JARs from the release.

compare to JeeTS approach: +
https://github.com/kbeigl/jeets/blob/master/jeets-parent/pom.xml
  
       <groupId>org.apache.camel.springboot</groupId>
    <artifactId>camel-spring-boot-dependencies</artifactId>


== google code style plugin

There are many code formatters and formats out there.
Just like in the `jeets` project we chose the   
https://github.com/spotify/fmt-maven-plugin

       <groupId>com.coveo</groupId>
    <artifactId>fmt-maven-plugin</artifactId>

The choice is based on simplicity and the most common code style with 
link:https://google.github.io/styleguide/javaguide.html[Google Java Style]. 
The plugin is strict about styling, cannot be configured by design 
and automatically formats the code before compilation.


=== useful mvn commands

Maven also provides 

    dependency:analyze 
    
plugin goal for analyzing the dependencies:
it helps making this best practice more achievable.

Most Maven plugins have a help goal
that prints a description of the plugin and its parameters and types. +
For instance, to see help for the javadoc goal, type:

      mvn javadoc:help -Ddetail -Dgoal=javadoc

== upgrades and updates

After releasing a repository version `v1,0`, `v1.1.1-SNAPSHOT` or `-RC` etc.
the major versions are upgraded. The following steps cover the vital coordinates 
and sometimes take more time than expected `:(` 

=== step 1 - maven versions  

  mvn versions:display-plugin-updates

=== step 2 - Camel and Spring versions  

The above maven command does not check the BOM versions.
Therefor they are incremented one by one until the repository
is completly build with `mvn install`.

        <camel-version>4.10.6</camel-version>
  <spring-boot-version>3.4.7</spring-boot-version>

We usually stick to the `LTS` versions provided.

=== step 3 - Java and JDK versions

Upgrading Java can be fine for the repository.
Nevertheless we would like to keep a compromise between highest available 
and lowest backward compatibility for users of the released jar files.

        <jdk.version>21</jdk.version>

=== step 4 - Tracar versions

This step is more than just a change of pom coordinates.
Traccar always has and still is evolving at a high pace and
for this repository especially the REST API is vital.
Therefor we go through this upgrade process, if there is time :(

For your purposes check the API version and most REST calls 
have been available for years and should be (backward) compatible
to your Traccar Server Version.

And the

    org.openapitools:openapi-generator-maven-plugin .. 7.13.0 -> 7.14.0

should be updated with the Traccar Version.

=== misc

 *  javadoc header: +
  license, project, @author etc. - compare jeets, traccar, camel

 * find . -type f -exec touch {} +
 
 
 
 
 
 
 